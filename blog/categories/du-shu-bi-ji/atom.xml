<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 读书笔记 | nomi's blog]]></title>
  <link href="http://nomi-wei.github.com/blog/categories/du-shu-bi-ji/atom.xml" rel="self"/>
  <link href="http://nomi-wei.github.com/"/>
  <updated>2013-04-07T17:33:56+08:00</updated>
  <id>http://nomi-wei.github.com/</id>
  <author>
    <name><![CDATA[nomi(Otto Lu)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective C++ 读书笔记(续)]]></title>
    <link href="http://nomi-wei.github.com/blog/2013/04/07/effective-c-plus-plus-note-part2/"/>
    <updated>2013-04-07T15:20:00+08:00</updated>
    <id>http://nomi-wei.github.com/blog/2013/04/07/effective-c-plus-plus-note-part2</id>
    <content type="html"><![CDATA[<p>介个是第二部分</p>

<h3>第五章</h3>

<h4>条款26:尽量延后变量定义式的出现时间</h4>

<p>构造和析构一个对象实例是要时空成本的,很多时候,如果一个分支跳出,或者异常,很可能之前定义初始化的对象都没用过哩,所以不用太早~不过会不会搞到代码不好看呢?</p>

<p>另外注意对象该放在哪,不然一个循环里面,n次构造,析构还是挺蛋疼的.</p>

<h4>条款27:尽量少做转型动作</h4>

<p>转型的资源消耗蛮大啊,要类型检查之类的(书上貌似说跟类名字符串比较有关,可能是我理解错了)</p>

<p><code>const_cast&lt;T&gt;(expression)</code> 去除常量标记的</p>

<p><code>dynamic_cast&lt;T&gt;(expression)</code> 安全向下转型</p>

<p><code>reinterpret_cast&lt;T&gt;(expression)</code> 执行低级转型,可强制赋一个地址值给某指针</p>

<p><code>static_cast&lt;T&gt;(expression)</code> 强迫隐式转换</p>

<p>建议用这些新式转换,第一因为它好找,第二因为难看,所以你会不大想用(不是我说的哦,是Bjarne Stroustrup说的~哈)</p>

<p>注意这种类型转换应该是生成一个新副本的,想调用其父类的函数时,不建议强制转换该指针去调用,因为其实是调用一个副本的~</p>

<h4>条款28:避免返回的handles指向对象内部成分</h4>

<p>这一条有点类似条款21,因为对象会有被析构的一天,而handle还在的话,容易造成问题,当然还是那一句<code>注意返回的究竟是啥玩意</code></p>

<h4>条款29:为"异常安全"而努力是值得的</h4>

<p>我觉得处理异常是个大专题,现阶段可能不好总结,就不深入分析了,尔后有机会认真研究.</p>

<p>其实有点像数据库对事务的处理一样,有atom的原则吧,计算机领域很多问题毕竟是互通的.</p>

<h4>条款30:透切了解inlining的里里外外</h4>

<p>inline是个好东西,不过其实主要原因是函数调用是需要开销的,貌似早期Ken那群老人家也争论过究竟应该函数写"小一点"还是"大一点"的问题.</p>

<p>当然inline会造成代码膨胀,毕竟每次调用其实就硬塞了进去一段代码而已~过度膨胀的代码容易导致额外的换页问题,降低cache的命中率尔尔;另外要注意,写在类里的函数实现一般是会inline的~</p>

<p>如果一个函数指针指向一个inline函数再调用自身,那它只是个普通函数而已.</p>

<p>另外inline函数会使得对他的改动需要重新编译,如果外链的函数库就不需要了,更换就好(有点绕,就是小心过度使用,搞得次次修改都得重新编译,费时)</p>

<h4>条款31:将文件间编译依存度关系降至最低</h4>

<p>这个具体解决方法太绕了,有点,当遇到这个问题的时候,再认真看看这里吧(pdf P170, 页码 P140)</p>

<p>主要是先声明类,后实现,然后多用指针定义,后实现.</p>

<h3>第六章</h3>

<h4>条款32:确定你的public继承塑造出is-a关系</h4>

<p>不解释.</p>

<h4>条款33:避免遮掩继承而来的名称</h4>

<p>tips:<code>using Base::func;</code>,<code>Base::func()</code>,反正要清楚自己在干什么就好</p>

<h4>条款34:区分接口继承和实现继承</h4>

<p>不解释,涉及类设计,接口设计</p>

<h4>条款35:考虑virtual函数以外的其他选择</h4>

<p>非常建议之后回去再看.涉及设计的了.</p>

<h4>条款36:绝不重新定义继承而来的non-virtual函数</h4>

<h4>条款37:绝不重新定义继承而来的缺省参数值</h4>

<p>设计rule,要清楚自己在干嘛就好.</p>

<p>不过这里有个比较有趣的地方,记住virtual是动态调用,会真正判断你这个类型是啥,再调用具体函数,实现多态;而其他都是静态调用,根据你的指针是啥类型,直接调用的;所以对virtual函数传入参数设置缺省值时,会有出现有趣的情况~</p>

<pre><code>// Class A
virtual void func(int i = 0){
  cout&lt;&lt;"A:"&lt;&lt;i&lt;&lt;endl;
}

// Class B extend A
virtual void func(int i = 1){
  cout&lt;&lt;"B:"&lt;&lt;i&lt;&lt;endl;
}

a-&gt;func(); // B:0, a实为B对象,但是多态为基类
</code></pre>

<h4>条款38:通过复合塑模出has-a或"根据某物实现出"</h4>

<h4>条款39:明智而审慎地使用private继承</h4>

<p>两者都略有表达has-a的意思,不过前者更合适,后者有特殊用途.</p>

<h4>条款40:明智而审慎地使用多重继承</h4>

<p>小心菱形继承,方法,变量命名冲突等问题,其实继承一个基类,其他都是虚类,想Java解决方式一样解决也不错</p>

<h3>第七章</h3>

<p>第七章蛮高深啊,template玩法很多,很深啊,不好总结啊,以后搞C++的话还是看书再深究吧.</p>

<h4>条款41:了解隐式接口和编译期多态</h4>

<p>要注意template的编译期多态的问题,在真正调用时才具象化一个实现的,编译期多态,运行期多态,太happy了~</p>

<h4>条款42:了解typename的双重意义</h4>

<p>要不我跳过吧...
有点像typedef~</p>

<h4>条款43:学习处理模板化基类的名称</h4>

<p>在适当的时候,可以使用模板的特例化去解决某些问题.</p>

<pre><code>// 一个特化版的MsgSender
template&lt;&gt;
class MsgSender&lt;CompanyZ&gt;{
  // 具体实现
}
</code></pre>

<h4>条款44:将与参数无关的代码抽离templates</h4>

<p>容易造成代码膨胀</p>

<h4>条款45:运用成员函数模板接受所有兼容类型</h4>

<h4>条款46:需要类型转换时请为模板定义非成员函数</h4>

<h4>条款47:请使用traits classes表现类型信息</h4>

<p>traits是能获取部分类型信息</p>

<p>(饿了 吃个饭继续写~)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective C++ 读书笔记]]></title>
    <link href="http://nomi-wei.github.com/blog/2013/04/07/effective-c-plus-plus-notes/"/>
    <updated>2013-04-07T11:52:00+08:00</updated>
    <id>http://nomi-wei.github.com/blog/2013/04/07/effective-c-plus-plus-notes</id>
    <content type="html"><![CDATA[<p>说起来真是挫逼,到现在才读ec++,现在终于找到自己想走的路,C C++ Javascript,是近几年的目标吧,希望能成为一个C后台开发者.</p>

<p>以后读完一本好书之后,也写写总结,不然读完很快就忘了,也留个以后参考.</p>

<h2>正文</h2>

<p>EC++确实是一本好书,这个看完没多久我就感受到了,很多地方,细节很快就用得上了.</p>

<p>总结的形式就每条细则的小点评吧.</p>

<h3>第一章</h3>

<h4>条款1:视C++为一个语言联邦</h4>

<p>C++确实比C变动太大,现在不得不吐槽一下那些说"C其实跟C++差不多的童鞋",C++增加了OO,Template(后文的元编程让人眼前一亮),STL标准库(不过据闻大公司很多都不用这块,尤其24hrs运作的服务器,因为容易造成内存碎片化),这三块应该是变动最大的部分吧,也是核心了吧.相比而言,C真的小巧优雅啊.</p>

<h4>条款2:尽量用const,enum,inline代替#define</h4>

<p>确实预编译的简单替换这个还是蛮蛋疼的,太容易出错了吧~这样也不利于编译器优化啊(比如常量替换时,会造成多个常量副本),调试也不方便,比如遇到一个常量有问题了,也很难监控,因为没有变量名.</p>

<p>enum hack能够创造一些常量,inline函数的话因为调试时有一个真正的函数,也会为调试带来方便,不然对着一堆代码很难知道原来是宏代码出错了,inline就没有定位的难题.</p>

<h4>条款3:尽可能使用const</h4>

<p>对输入,返回值加上合适的const能更容易发现错误,在编译阶段就能察觉.</p>

<p>至于指针型的const,可以采取右往左读的方式,<code>const char* const p</code> a const pointer to const char, 另外<code>const xxx::iterator iter</code> iter是const,<code>xxx::const_iterator iter</code> *iter是const;</p>

<p>然后还有函数const的问题,更多倾向于编程思想的讨论,就不细聊了,暂时注意点就好,尽量声明为const函数时,就小心不经意会改动该对象.</p>

<h4>条款4:确定对象被使用前已先被初始化</h4>

<pre><code>class T{
  private:
    int t;

  public:
    T(int _t){
      t = _t;
    }
}
</code></pre>

<p>这样低效,因为是系统初始化,再手动赋值了~</p>

<pre><code>class T{
  private:
    int t;

  public:
    T(int _t):t(_t){}
}
</code></pre>

<p>记住了~</p>

<p>还有可以用单例的手法避免对象具象化顺序问题,具体就是用static返回一个对象就好了~(不详细说了,忘了的话就看书吧,pdf P61,书码P31).小心多线程.</p>

<h3>第二章</h3>

<h4>条款5:了解C++默默编写并调用哪些函数</h4>

<p>主要是构造,析构,copy构造,=重载,这几个吧.</p>

<h4>条款6:若不想使用编译器自动生成的函数,就该明确拒绝</h4>

<p>就是手动把他显式写成private就好了</p>

<h4>条款7:为多态基类声明virtual析构函数</h4>

<p>避免在使用多态特性的时候,只析构了父类的部分~你懂的</p>

<h4>条款8:别让异常逃离析构函数</h4>

<p>容易发生不明确行为.反正就这样记吧.</p>

<h4>条款9:绝不在构造和析构过程中调用virtual函数</h4>

<p>因为会调用父类virtual函数的部分当调用父类构造函数时,如果其有调用该virtual函数的话(有点绕,可能表达略不当)</p>

<h4>条款10:令operator=返回一个reference to *this</h4>

<p>为了可以连续赋值(其实返回自身就可以实现了),和实现一些特殊操作吧,如<code>(T = 5).x = 'demo'</code>.</p>

<h4>条款11:在operator=中处理自我赋值</h4>

<p>建议传入值再调用swap的方法处理,貌似不够高效~反正注意就好</p>

<h4>条款12:复制对象时勿忘其每一个成分</h4>

<p>不解释,记住调用父类的copy函数</p>

<h3>第三章</h3>

<h4>条款13:以对象管理资源</h4>

<p>这就是RAII(资源取得的时机就是初始化时机)出现的地方了,用tr1::shared_ptr包装一下该资源,就不会不记得释放了吧~
ps:auto_ptr复制动作会使原来那个指向null</p>

<h4>条款14:在资源管理类中小心coping行为</h4>

<p>tr1::shared_ptr包装一个包装类就好,shared_ptr能设定默认的删除器</p>

<h4>条款15:在资源管理类中提供对原始资源的访问</h4>

<h4>条款16:成对使用new和delete时要采取相同的形式</h4>

<p>记住这话吧.</p>

<h4>条款17:以独立语句将newed对象置入智能指针</h4>

<p>主要说了不用一句代码包含太多东西,拆分一下,避免异常时,不好解决.</p>

<h3>第四章</h3>

<h4>条款18:让接口容易被正确使用,不易被误用</h4>

<p>这个涉及设计理念了,在写Unix编程思想的读书笔记时,可以深入总结.</p>

<h4>条款19:设计class犹如设计type</h4>

<p>不解释.</p>

<h4>条款20:宁以pass-by-reference-const替换pass-by-value</h4>

<ol>
<li>效率原因;</li>
<li>如果传入参数命名为父类想多态调用的话,pass-by-value的话会数据截断;</li>
<li>基本类型,STL迭代器,函数对象的话,pass-by-value往往更好;
(函数对象是个比较有趣的东西)</li>
</ol>


<h4>条款21:必须返回对象时,别妄想返回其reference</h4>

<ol>
<li>如果返回的东西是在函数类定义的(非new),那么函数调用后,就回收栈内存了,木有了;</li>
<li>主要返回引用太容易造成指向空对象的问题的,要小心;</li>
</ol>


<h4>条款22:将成员变量声明为private</h4>

<p>就是注意封装性.</p>

<h4>条款23:宁以non-member,non-friend替换member函数</h4>

<p>这里说法有点过于绝对了,个人理解还是跟类设计相关的,跟类本身紧密相连的方法,还是肯定应该为成员函数的.</p>

<h4>条款24:若所有参数皆需类型转换,请为此采用non-member函数</h4>

<p>看<code>result = 2 * result</code>如果用member函数重载的话,就咔嚓了,全局重载还是蛮不错的哦~(卖个萌</p>

<h4>条款25:考虑写一个不抛异常的swap函数</h4>

<blockquote><p>swap是个有趣的函数,原本它只是STL的一部分,而后成为异常安全性编程的脊柱.</p></blockquote>

<p>有机会要搜搜啊,记得.</p>

<p>这个有点高深,不好总结,写swap函数用时记得看看(pdf P140,页码 P110)</p>

<p>来个中场休息吧~
后边另起一篇,不然有点太长了~</p>
]]></content>
  </entry>
  
</feed>
